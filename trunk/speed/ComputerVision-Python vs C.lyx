#LyX 1.6.2 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass IEEEtran
\use_default_options true
\begin_modules
theorems-ams
\end_modules
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Comparing Python and C for Computer Vision
\begin_inset Note Note
status open

\begin_layout Plain Layout
Comparing Python and C for Computer Vision?
\end_layout

\begin_layout Plain Layout
Developing Computer Vision Programs?
\end_layout

\begin_layout Plain Layout
Cprofiling gprof, cProfile in python
\end_layout

\begin_layout Plain Layout
http://developer.apple.com/tools/sharkoptimize.html
\end_layout

\begin_layout Plain Layout
You should have few code snippets, maybe 3 will sufficient, the rest in
 the appendices yes.
\end_layout

\end_inset


\end_layout

\begin_layout Author
Brian Thorne, Raphael Grasset, Richard Green
\begin_inset Newline newline
\end_inset

HIT Lab NZ, University of Canterbury, Private Bag 4800, Christchurch
\begin_inset Newline newline
\end_inset

Email: {brian.thorne|raphael.grasset|richard.green}@hitlabnz.org
\end_layout

\begin_layout Keywords
Computer Vision, OpenCV, Python, C++
\end_layout

\begin_layout Abstract
An introduction to and argument for programming computer vision applications
 and scripts in Python in place of the C/C++ programming language.
 From the general concept to its implementation with some current open-source
 libraries (OpenCV, NumPy/SciPy, Pygame).
 
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
The purpose of this paper is an introduction to computer vision (CV) and
 image processing using the multipurpose programming language Python.
 At present the bulk of computer vision applications are programmed in C
 or C++.
 There a significant benefits to developer time if Python is a viable alternativ
e.
 This paper aims to show what is possible with current libraries, demonstrate
 their usability, explore their limitations, compare performance and cover
 elements of best coding practice.
\end_layout

\begin_layout Standard
To Compare performance between C++ and Python for computer vision the OpenCV
 library is used to show different examples of computer vision.
 Examples analyzed include displaying a video image, filtering algorithms
 (dilation, gaussian blur), and how to implement facial recognition.
 We go on to describe how these and other computer vision related tasks
 can be achieved with other Python tools such as SciPy
\begin_inset CommandInset citation
LatexCommand cite
key "oliphant2007python"

\end_inset

.
 I will show how these libraries can be used in conjunction to perform video
 capturing, image processing and video feedback.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
if it's OpenCV in C++ and OpenCV in Python, use a simple notation: OPENCV_C++,
 OPENCV_PY that you introduce in the text.
 just for tables?
\end_layout

\end_inset


\end_layout

\begin_layout Section
Background
\end_layout

\begin_layout Subsection
Python
\end_layout

\begin_layout Standard
Python is a general purpose dynamic programming language
\begin_inset CommandInset citation
LatexCommand cite
key "entry-0"

\end_inset

.
 It is highly regarded due in no small part for its fast development time.
\end_layout

\begin_layout Subsection
OpenCV
\end_layout

\begin_layout Standard
Intel's open source computer vision libraries...
 History, capabilities.
 C library.
 Python bindings.
 IPP.
 For the tests carried out in this paper the latest tested snapshot of OpenCV
 1.1.1 was used.
\end_layout

\begin_layout Subsection
NumPy
\end_layout

\begin_layout Standard
NumPy gives N-dimensional arrays to python
\begin_inset CommandInset citation
LatexCommand cite
key "oliphant2006guide"

\end_inset

.
 Has very fast raw data crunching, iterating.
 Much easier to use than multidimensional matrices in C.
\end_layout

\begin_layout Subsection
SciPy
\end_layout

\begin_layout Standard
SciPy
\begin_inset CommandInset citation
LatexCommand cite
key "jones2001scipy"

\end_inset

 is a set of Python libraries and tools for scientific and mathematical
 work build on top of NumPy
\begin_inset CommandInset citation
LatexCommand cite
key "oliphant2007python"

\end_inset

.
 SciPy has filters and convolution etc much like Matlab.
 Should be much simpler higher level code, without any significant performance
 loss.
\end_layout

\begin_layout Section
Theory of operation
\end_layout

\begin_layout Subsection
Image Acquisition
\end_layout

\begin_layout Standard
The first thing to think about in computer vision programs is where the
 image data comes from.
 In this report only live data from a web-cam is under consideration.
 The main difference in using a live system is the time available for processing
 is very constrained to allow a frame rate sufficient for live viewing.
 Processing on static images or recorded video data doesn't have this constraint.
\end_layout

\begin_layout Subsubsection
Acquiring and displaying an image in C with OpenCV
\end_layout

\begin_layout Standard
Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:C-Image-capture"

\end_inset

 opens up a new camera capture device, and takes one frame, it creates a
 new window and displays it
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
For brevity these code snippets do not carry out error checking or cleanup.
 It is assumed that a camera was found successfully and that a frame was
 available and returned.
 The C++ and Python versions of VideoCapturePlayer do carry out this error
 checking.
\end_layout

\end_inset

.
 Using this as a template it is straight forward to wrap the capture and
 display in a loop, this forms the basis of the C++ class 
\noun on
VideoCapturePlayer
\noun default
 included in the appendix.
 This 
\noun on
VideoCapturePlayer
\noun default
 class is used in the other examples to keep the code duplication and variation
 to a minimum.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement h
wide false
sideways false
status collapsed

\begin_layout LyX-Code
#include "cv.h"
\end_layout

\begin_layout LyX-Code
#include "highgui.h"
\end_layout

\begin_layout LyX-Code
int main(){
\end_layout

\begin_layout LyX-Code
  IplImage  *frame;
\end_layout

\begin_layout LyX-Code
  CvCapture *capture;
\end_layout

\begin_layout LyX-Code
  capture = cvCreateCameraCapture(0);
\end_layout

\begin_layout LyX-Code
  cvNamedWindow( "Snapshot", 0 );
\end_layout

\begin_layout LyX-Code
  frame = cvQueryFrame( capture );
\end_layout

\begin_layout LyX-Code
  cvShowImage( "Snapshot", frame );
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:C-Image-capture"

\end_inset

Image capture and display with OpenCV in C.
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Acquiring and displaying an image in Python with OpenCV
\end_layout

\begin_layout Standard
Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Python-Image-capture"

\end_inset

 does the same basic task of accessing a webcam and displaying one image
 in Python.
 The code is almost entirely identical in C and Python.
 The main difference being in the Python code no variables types are declared,
 this shows the dynamic nature of the language.
 As with C++, an object orientated version of this acquisition loop with
 error checking is used in further tests.
 The 
\noun on
VideoCapturePlayer
\noun default
 classes in both C++ and Python optionally take a function as an argument.
 This function takes the raw image, does some process on it, and returns
 an image for display.
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement h
wide false
sideways false
status collapsed

\begin_layout LyX-Code
from opencv import highgui as hg
\end_layout

\begin_layout LyX-Code
capture = hg.cvCreateCameraCapture(0)
\end_layout

\begin_layout LyX-Code
hg.cvNamedWindow("Snapshot")
\end_layout

\begin_layout LyX-Code
frame = hg.cvQueryFrame(capture)
\end_layout

\begin_layout LyX-Code
hg.cvShowImage("Snapshot", frame)
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:Python-Image-capture"

\end_inset

Image capture and display in Python
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Comparison
\end_layout

\begin_layout Standard
Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:IO-bound-Webcam"

\end_inset

 shows results for taking an image from a webcam and displaying the image
 with OpenCV.
 The average frames per second are taken over 3 runs each averaging over
 a 2 minute period.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:IO-bound-Webcam"

\end_inset

Simple IO bound test - Webcam streaming comparison of Python and C++.
 Results shown are in frames per second.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="6">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Language
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Run 1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Run 2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Run 3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mean
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Std Dev
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Python
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15.007
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15.003
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15.007
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15.006 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2.25E-03 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C++
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15.017
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15.009
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15.010
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15.012 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.27E-03 
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
As the results in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:IO-bound-Webcam"

\end_inset

and Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Streaming-comparison"

\end_inset

 show, Python and C++ perform at very similar rates whilst carrying out
 an I/O bound task.
 The not unexpected result points at C++ having a marginally higher frame
 rate output than Python.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename report_data/streaming_from_webcam_in_opencv.png
	lyxscale 50
	width 80col%

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Streaming-comparison"

\end_inset

Comparison of Python and C++ performance using OpenCV for webcam capture
 and display.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Image Blur
\end_layout

\begin_layout Standard
One of the simplest operations in image processing is blurring an image.
 This can be achieved in a few ways, the method looked at here is by adding
 gaussian blur.
 Mathematically this is achieved by convolving the image with a gaussian
 filter.
 Because of the separability of multidimensional gaussian filters
\begin_inset CommandInset citation
LatexCommand cite
key "young1995recursive"

\end_inset

, the convolution can be applied in two ways; applying a 1 dimensional filter
 twice, once in each direction; or secondly the image can be convolved with
 a 2-dimensional gaussian filter created by the product of two 1 dimensional
 filters.
 Equation 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:1D Gaussian Filter"

\end_inset

 shows the gaussian function for obtaining the filter is in one dimension
\begin_inset CommandInset citation
LatexCommand cite
key "SS01"

\end_inset

.
 
\begin_inset Formula \begin{equation}
G\left(x\right)=\frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{x^{2}}{2\sigma^{2}}}\label{eq:1D Gaussian Filter}\end{equation}

\end_inset


\begin_inset Formula \begin{equation}
G\left(x,y\right)=\frac{1}{\sqrt{2\pi}\sigma^{2}}e^{-\frac{x^{2}+y^{2}}{2\sigma^{2}}}\label{eq:2D Gaussian Filter}\end{equation}

\end_inset

Equation 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:2D Gaussian Filter"

\end_inset

 shows the 2 dimensional case
\begin_inset CommandInset citation
LatexCommand cite
key "SS01"

\end_inset

.
 OpenCV includes a gaussian filter that can be applied to an image by calling
 the 
\emph on
\noun on
cvSmooth
\emph default
\noun default
 function and passing the desired window size.
 SciPy has a n-dimensional Gaussian filter that acts on a NumPy array.
 Both libraries use the 1 dimensional case, as it requires less calculations.
\end_layout

\begin_layout Subsubsection
C++
\end_layout

\begin_layout Standard
Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Gaussian-C"

\end_inset

 shows calling the OpenCV function 
\noun on
cvSmooth
\noun default
 to carry out gaussian blur with a filter size of 43.
 
\end_layout

\begin_layout Subsubsection
Python
\end_layout

\begin_layout Standard
Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Gaussian-Python-OpenCV"

\end_inset

 shows Python taking advantage of VideoCapturePlayer, the Python class mentioned
 above to do the same blurring operation with OpenCV
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
A helper function here calculates the sigma value to use in the convolution,
 this is usually done automatically in OpenCV, but to port to SciPy the
 parameters must all be known.
\end_layout

\end_inset

.
 Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Gaussian-Python-SciPy"

\end_inset

 is also using the VideoCapturePlayer but this time using SciPy instead
 of OpenCV to do the convolution.
 To continue using the OpenCV camera capture, the image data must be converted
 into NumPy arrays; this has been achieved here by creating and using a
 Python decorator which converts before and after calling a Python function
 using NumPy.
 Also the filter parameters need converted to be compatible with OpenCV's
 
\noun on
cvSmooth
\noun default
 defaults
\begin_inset CommandInset citation
LatexCommand cite
key "bradski2008learning"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Comparison
\end_layout

\begin_layout Standard
As expected the images produced by this are blurred as shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Gaussian-Output-Images"

\end_inset

.
 For qualitative comparison a static input image was used.
 What is not immediately obvious without further investigation is how similar
 the results are.
 The OpenCV images produced by C++ and Python are exactly the same pixel
 for pixel, this is expected because the same function is doing the filtering.
 More interesting is figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Difference-in-Python"

\end_inset

 which shows that the SciPy and OpenCV Python code doing the filtering produces
 slightly different results.
 This could be caused by the floating point nature of the convolution, as
 the difference is very small.
 It may be due to a type difference or a small difference in the algorithms.
 Or possibly since SciPy uses the sigma parameter, the filter is created
 by direct sampling of the Gaussian function.
 On the other side, OpenCV uses the size(in pixels) of the filter.
 This is a good indication it probably uses the pascal triangle as an approximat
ion for the Gaussian kernel.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename report_data/blurred_imag_cpp_opencv_gaussian.jpg
	lyxscale 20
	width 30col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
C++
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename report_data/blurred_imag_python_opencv_gaussian.jpg
	lyxscale 20
	width 30col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Python OpenCV
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename report_data/blurred_imag_python_scipy_gaussian.jpg
	lyxscale 20
	width 30col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Python SciPy
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename report_data/python_gaussian_diffpng.png
	lyxscale 20
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Difference-in-Python"

\end_inset

Difference in OpenCV and SciPy
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Gaussian-Output-Images"

\end_inset

Output Images from Gaussian Blur Examples
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:Gaussian-Results"

\end_inset

CPU bound test results - Gaussian Blur filtering on webcam stream (in fps)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="6">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Language
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Run 1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Run 2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Run 3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mean
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Std Dev
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Python
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
14.555
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
14.737
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13.989
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
14.427
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.318
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C++
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
14.722
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
14.627
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
14.612
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
14.653
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.049
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SciPy
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.374
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.3886
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.337
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.3664
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.0219
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename report_data/gaussian_blur.png
	lyxscale 50
	width 80col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:performance-gaussian"

\end_inset

OpenCV performance carrying out Gaussian Blur
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Background subtractions
\end_layout

\begin_layout Standard
Double Diff, Graph Cut maybe....
\end_layout

\begin_layout Standard
reference Richard Greens paper
\end_layout

\begin_layout Subsection
Feature Point Detection
\end_layout

\begin_layout Standard
Many methods in computer vision for identifying the contents of an image
 relies on extracting 
\emph on
interesting
\emph default
 features.
 An interesting feature point could be corners of intersecting lines, a
 line ending, or any isolated point where local image regions have a high
 degree of variation in all directions
\begin_inset CommandInset citation
LatexCommand cite
key "harris1988combined"

\end_inset

.
 The features must be found algorithmically and have a well-defined position.
 The repeatability of choosing the same points under differing conditions
 is a measure of how good an interesting feature algorithm is.
 The corner detection algorithm works by locating points where the surroundings
 have edges in more than one direction.
 Harris & Stephens algorithm is in short: 
\end_layout

\begin_layout Quote
A matrix W is created from the outer product of the image gradient, this
 matrix is averaged over a region and then a corner response function is
 defined as the ratio of the determinant to the trace of W.
\begin_inset CommandInset citation
LatexCommand cite
key "Sol09"

\end_inset


\end_layout

\begin_layout Standard
A threshold is then applied to this corner response image to pick the most
 likely candidates and then these points are plotted.
 An example usage of the algorithm is in the Lucas–Kanade Optical Flow Method
 where it can be used to select good feature points
\begin_inset CommandInset citation
LatexCommand cite
key "beauchemin1995computation"

\end_inset

 for tracking movement.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename static_harris_file.png
	lyxscale 30
	width 45col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
static image processing
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename temp_harris_file_248_points.png
	lyxscale 30
	width 45col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
processing from webcam
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:A-SciPy-harris"

\end_inset

A SciPy implementation of the Harris & Stephens feature detection algorithm.
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename report_data/opencv_python_harris.png
	lyxscale 30
	width 90col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:OpenCV-harris"

\end_inset

OpenCV implementation of the Harris & Stephens feature detection algorithm
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:SciPy-Harris-Corner"

\end_inset

 modified an existing implementation in SciPy by 
\begin_inset CommandInset citation
LatexCommand cite
key "Sol09"

\end_inset

 which produced figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:A-SciPy-harris"

\end_inset

.
 The same concept but in a different implementation is shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:OpenCV-harris"

\end_inset

 for OpenCV in algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Harris-Detection-opencv"

\end_inset

.
 Note care has not been taken to get the exact same output in OpenCV as
 in SciPy, it is assumed that one could get the same output as shown earlier
 with the gaussian blur example.
 The main difference between algorithms 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:SciPy-Harris-Corner"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Harris-Detection-opencv"

\end_inset

 is the filtering and display of the corner response.
 Not implemented here is the OpenCV response in C++.
\end_layout

\begin_layout Subsection
Face Detection
\end_layout

\begin_layout Standard
Face detection is the task of locating a face in an image, this is a specific
 case of a general object detection.
 Before locating an object, one must be able to describe it.
 Many object detection algorithms use a classifier which is a collection
 of feature patterns made by scanning a database of images with known content.
 Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:OpenCV-Haar-detect"

\end_inset

 shows how to use the OpenCV library to detect the location of any object
 provided a Haar Classifier describing that object is provided.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:OpenCV-Face-Detection"

\end_inset

 shows the output under different conditions when using the face Haar-cascade
 classifier that comes with OpenCV.
 The method gave a mean framerate of 7.16 ± 0.02 Hz.
 The detection method used has limitations as shown in fig 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Obscured-opencv-face"

\end_inset

 and fig 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Angled-opencv-face"

\end_inset

.
 But in ideal conditions, with good lighting and unobscured faces directly
 facing the camera the algorithm produces very good results.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename report_data/face_detect_one.png
	lyxscale 30
	width 45col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Single face in frame
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename report_data/face_detect_obscure.png
	lyxscale 30
	width 45col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Obscured-opencv-face"

\end_inset

Obscured face in frame
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename report_data/face_detect_two.png
	lyxscale 30
	width 45col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Multiple faces
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename report_data/face_detect_sideways.png
	lyxscale 30
	width 45col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Angled-opencv-face"

\end_inset

Rotated face
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:OpenCV-Face-Detection"

\end_inset

OpenCV Face Detection
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename report_data/pygame-eye-locate.png
	lyxscale 50
	width 90col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Pygame-object"

\end_inset

Pygame can be used to capture and display the webcam, while OpenCV does
 the processing.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Pygame-object"

\end_inset

 shows an alternative setup; using Pygame for image capture, OpenCV for
 the object detection and Pygame for the rendering.
 Python really shows its strengths as a glue language here, as the different
 libraries are easily used in conjunction.
 The benifits from this can be huge, it is very easy for a developer to
 incorperate different computer vision tools, even with very limited knowledge
 of computer vision.
\end_layout

\begin_layout Section
Related Works
\end_layout

\begin_layout Standard
Part 2 should be "related works" as referencing people comparing: different
 version of CV library in different languages, in different platforms, maybe
 also people using OpenCV+IPL, people having implementing other CV library
 in Python, etc.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Thank Rob for the profiling help
\end_layout

\end_inset


\end_layout

\begin_layout Section
Conclusions
\end_layout

\begin_layout Standard
Initial thoughts are that Python will be slow, but for many applications
 probably fast enough not to notice.
 The benefits for quick prototyping of new algorithms and using those prototypes
 in the final product is a serious draw card...
\end_layout

\begin_layout Standard
Limitations (other than speed), hardware, firewire, support, libraries and
 functionality?
\end_layout

\begin_layout Section
Appendix
\end_layout

\begin_layout Subsection
Code Listings
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide true
sideways false
status collapsed

\begin_layout LyX-Code
#include <iostream> 
\end_layout

\begin_layout LyX-Code
#include "videoCapturePlayer.h"
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
CvMat * gaussianBlur(CvMat *x){
\end_layout

\begin_layout LyX-Code
// Filter with gaussian smoothing
\end_layout

\begin_layout LyX-Code
    int filterSize = 43;
\end_layout

\begin_layout LyX-Code
    cvSmooth(x, x, CV_GAUSSIAN, filterSize);
\end_layout

\begin_layout LyX-Code
    return x;
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
int main( int argc, char** argv ){
\end_layout

\begin_layout LyX-Code
    VideoCapturePlayer vcp = VideoCapturePlayer(&gaussianBlur);
\end_layout

\begin_layout LyX-Code
    vcp.init(); vcp.main();
\end_layout

\begin_layout LyX-Code
    return 0;
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:Gaussian-C"

\end_inset

Applying Gaussian Blur to web-cam stream from C++
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float algorithm
wide true
sideways false
status collapsed

\begin_layout LyX-Code
from VideoCapturePlayer import VideoCapturePlayer as VCP
\end_layout

\begin_layout LyX-Code
from opencv import cv
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
def opencvFilt2sigma(size):
\end_layout

\begin_layout LyX-Code
    return (( size*0.5 ) - 1)*0.30 + 0.80
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
def gaussianBlur(image):
\end_layout

\begin_layout LyX-Code
    """Blur an image"""     
\end_layout

\begin_layout LyX-Code
    result = cv.cvCreateMat(image.rows, image.cols, image.type)
\end_layout

\begin_layout LyX-Code
    filterSize = 43; sigma = opencvFilt2sigma(filterSize)
\end_layout

\begin_layout LyX-Code
    cv.cvSmooth(image, result, cv.CV_GAUSSIAN, filterSize,0, sigma)
\end_layout

\begin_layout LyX-Code
    return result
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
VCP(gaussianBlur, "Gaussian Filtered Output").main()
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:Gaussian-Python-OpenCV"

\end_inset

Gaussian Blurring in Python using OpenCV
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float algorithm
wide true
sideways false
status collapsed

\begin_layout LyX-Code
from numpy import array, uint8
\end_layout

\begin_layout LyX-Code
from scipy import signal, ndimage 
\end_layout

\begin_layout LyX-Code
from VideoCapturePlayer import VideoCapturePlayer as VCP 
\end_layout

\begin_layout LyX-Code
from misc import scipyFromOpenCV
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
def opencvFilt2sigma(size):
\end_layout

\begin_layout LyX-Code
    """OpenCV defaults to making sigma up with this formula"""
\end_layout

\begin_layout LyX-Code
    return (( size/2 ) - 1)*0.30 + 0.80
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
@scipyFromOpenCV
\end_layout

\begin_layout LyX-Code
def gaussianBlur(np_image):
\end_layout

\begin_layout LyX-Code
    """Blur an image with scipy"""
\end_layout

\begin_layout LyX-Code
    filterSize = opencvFilt2sigma(43)
\end_layout

\begin_layout LyX-Code
    result = ndimage.filters.gaussian_filter(np_image, (filterSize, filterSize,
 1))
\end_layout

\begin_layout LyX-Code
    return result
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
if __name__ == "__main__":
\end_layout

\begin_layout LyX-Code
    title = "Gaussian Filtered Output"
\end_layout

\begin_layout LyX-Code
    VCP(gaussianBlur,title=title).main()
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:Gaussian-Python-SciPy"

\end_inset

Gaussian Blurring in Python using SciPy
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float algorithm
wide true
sideways false
status collapsed

\begin_layout LyX-Code
def gauss_derivatives(im, n, ny=None):
\end_layout

\begin_layout LyX-Code
     """ returns x and y derivatives of an image using gaussian
\end_layout

\begin_layout LyX-Code
          derivative filters of size n.
 The optional argument
\end_layout

\begin_layout LyX-Code
          ny allows for a different size in the y direction."""
\end_layout

\begin_layout LyX-Code
    gx,gy = gauss_derivative_kernels(n, sizey=ny)
\end_layout

\begin_layout LyX-Code
    imx = signal.convolve(im,gx, mode='same')
\end_layout

\begin_layout LyX-Code
    imy = signal.convolve(im,gy, mode='same')
\end_layout

\begin_layout LyX-Code
    return imx,imy
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
   def compute_harris_response(image):
\end_layout

\begin_layout LyX-Code
       """ compute the Harris corner detector response function
\end_layout

\begin_layout LyX-Code
        for each pixel in the image"""
\end_layout

\begin_layout LyX-Code
        imx,imy = gauss_derivatives(image, 3)
\end_layout

\begin_layout LyX-Code
        gauss = gauss_kern(3)
\end_layout

\begin_layout LyX-Code
        Wxx = signal.convolve(imx*imx,gauss, mode='same')
\end_layout

\begin_layout LyX-Code
        Wxy = signal.convolve(imx*imy,gauss, mode='same')
\end_layout

\begin_layout LyX-Code
        Wyy = signal.convolve(imy*imy,gauss, mode='same')
\end_layout

\begin_layout LyX-Code
        Wdet = Wxx*Wyy - Wxy**2
\end_layout

\begin_layout LyX-Code
        Wtr = Wxx + Wyy
\end_layout

\begin_layout LyX-Code
        return Wdet / Wtr
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:SciPy-Harris-Corner"

\end_inset

SciPy Harris Corner Detection
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float algorithm
wide true
sideways false
status collapsed

\begin_layout LyX-Code
def detectObject(self,img):
\end_layout

\begin_layout LyX-Code
    gray = cvCreateImage( cvSize(img.width,img.height), 8, 1 )
\end_layout

\begin_layout LyX-Code
    small_img = cvCreateImage( cvSize( cvRound (img.width/self.image_scale),
 
\end_layout

\begin_layout LyX-Code
                              cvRound (img.height/self.image_scale)), 8, 1
 )
\end_layout

\begin_layout LyX-Code
    cvCvtColor( img, gray, CV_BGR2GRAY )
\end_layout

\begin_layout LyX-Code
    cvResize( gray, small_img, CV_INTER_LINEAR )
\end_layout

\begin_layout LyX-Code
    cvEqualizeHist( small_img, small_img )
\end_layout

\begin_layout LyX-Code
    cvClearMemStorage( self.storage )
\end_layout

\begin_layout LyX-Code
    if( self.cascade ):
\end_layout

\begin_layout LyX-Code
        t = cvGetTickCount()
\end_layout

\begin_layout LyX-Code
        objects = cvHaarDetectObjects( small_img, self.cascade, self.storage,
\end_layout

\begin_layout LyX-Code
                   self.haar_scale, self.min_neighbors, self.haar_flags, self.min_si
ze )
\end_layout

\begin_layout LyX-Code
        t = cvGetTickCount() - t
\end_layout

\begin_layout LyX-Code
        if verbose:
\end_layout

\begin_layout LyX-Code
            print "%i objects found, detection time = %gms" % (objects.total,t/(c
vGetTickFrequency()*1000.))
\end_layout

\begin_layout LyX-Code
        return objects
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:OpenCV-Haar-detect"

\end_inset

Using the OpenCV Haar Detect Objects Function
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float algorithm
wide true
sideways false
status collapsed

\begin_layout LyX-Code
#!/usr/bin/env python
\end_layout

\begin_layout LyX-Code
from VideoCapturePlayer import VideoCapturePlayer as VCP
\end_layout

\begin_layout LyX-Code
import numpy
\end_layout

\begin_layout LyX-Code
from scipy.ndimage import gaussian_filter,maximum_filter
\end_layout

\begin_layout LyX-Code
from numpy import array,ones,zeros,nonzero
\end_layout

\begin_layout LyX-Code
from opencv import cv
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
def harrisResponse(image, n = 15):
\end_layout

\begin_layout LyX-Code
  """Modified from PyVision example
\end_layout

\begin_layout LyX-Code
  """
\end_layout

\begin_layout LyX-Code
  gray = cv.cvCreateImage( cv.cvGetSize(image), 8, 1 )
\end_layout

\begin_layout LyX-Code
  corners = cv.cvCreateImage( cv.cvGetSize(image), 32, 1 )
\end_layout

\begin_layout LyX-Code
  cv.cvCvtColor( image, gray, cv.CV_BGR2GRAY )
\end_layout

\begin_layout LyX-Code
  cv.cvCornerHarris(gray,corners, n)
\end_layout

\begin_layout LyX-Code
  
\end_layout

\begin_layout LyX-Code
  # Filter the response and draw points
\end_layout

\begin_layout LyX-Code
  buffer = corners.imageData
\end_layout

\begin_layout LyX-Code
  corners = numpy.frombuffer(buffer,numpy.float32)
\end_layout

\begin_layout LyX-Code
  corners = corners.reshape(corners.height,corners.width)
\end_layout

\begin_layout LyX-Code
  corners = corners.transpose()
\end_layout

\begin_layout LyX-Code
  
\end_layout

\begin_layout LyX-Code
  footprint = ones((n,n))
\end_layout

\begin_layout LyX-Code
  mx = maximum_filter(corners, footprint = footprint)
\end_layout

\begin_layout LyX-Code
  local_maxima = (corners == mx) * (corners != zeros(corners.shape))
\end_layout

\begin_layout LyX-Code
  points = nonzero(local_maxima)
\end_layout

\begin_layout LyX-Code
  del local_maxima
\end_layout

\begin_layout LyX-Code
  points = array([points[0],points[1]]).transpose()
\end_layout

\begin_layout LyX-Code
  L = []
\end_layout

\begin_layout LyX-Code
  for each in points:
\end_layout

\begin_layout LyX-Code
    L.append((corners[each[0],each[1]],each[0],each[1],None))
\end_layout

\begin_layout LyX-Code
    i = cv.cvPoint(int(each[0]),int(each[1]))
\end_layout

\begin_layout LyX-Code
    cv.cvCircle(image, i, 2, cv.CV_RGB(0,0,200),3 )
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
  return image
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
title = "Harris Feature Detection"
\end_layout

\begin_layout LyX-Code
VCP(harrisResponse, title).main()
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:Harris-Detection-opencv"

\end_inset

Harris Detection in OpenCV
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section*
Software Links
\end_layout

\begin_layout Itemize
Pygame - a game making package for Python, aimed at new programmers.
 It has a camera module and is able to do basic computer vision tasks, or
 call on SciPy/NumPy.
 http://pygame.org
\end_layout

\begin_layout Itemize
Pycam - All code from this project, my framework linking OpenCV to Pygame
 and NumPy.
 http://pycam.googlecode.com
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "report_data/database"
options "ieeetr"

\end_inset


\end_layout

\end_body
\end_document
