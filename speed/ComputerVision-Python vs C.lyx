#LyX 1.6.2 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass IEEEtran
\use_default_options true
\begin_modules
theorems-ams
\end_modules
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Using Python in Computer Vision: Approach, Performance and Usability 
\end_layout

\begin_layout Author
Brian Thorne, Raphael Grasset, Richard Green
\begin_inset Newline newline
\end_inset

HIT Lab NZ, University of Canterbury, Private Bag 4800, Christchurch
\begin_inset Newline newline
\end_inset

Email: {brian.thorne|raphael.grasset|richard.green}@hitlabnz.org
\end_layout

\begin_layout Abstract
Python is a popular language widely used by the scientific community due
 to its clear syntax and an extensive number of specialized packages.
 For image processing or computer vision development, two libraries are
 prominently used: 
\shape italic
NumPy/SciPy
\shape default
 and a python wrapper of 
\shape italic
OpenCV
\shape default
.
 In this paper, we present a comparative evaluation of both libraries, assessing
 their performance as well as their usability.
 We also describe how Python implementation of OpenCV performs in comparison
 to the native C++ implementation.
 Our relevant findings and recommendations for the scholar community are
 also presented.
 
\end_layout

\begin_layout Keywords
Computer Vision, Python, SciPy, OpenCV
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Python
\begin_inset CommandInset citation
LatexCommand cite
key "van1994python"

\end_inset

 has been of growing interest to the academic community over the last decade.
 The increase of computational science as a scientific method drives the
 need for scientists to implement different mathematical models or simulation
 processes.
 The simple syntax of Python, high level dynamic data types, and automated
 memory management has retained their attention and forged it as a popular
 tool for the research community.
\end_layout

\begin_layout Standard
Differently, the field of image processing and computer vision (CV) has
 been driven for the last decade by C/C++ implementation and the usage of
 MATLAB
\begin_inset CommandInset citation
LatexCommand cite
key "kovesi-matlab"

\end_inset

.
 Although MATLAB offers an efficient high level platform for prototyping
 and testing algorithms, its performances doesn't compete with a well designed
 and optimized C++ implementation.
 More recently, we have seen the emergence of potential and valuable solution
 for developing image processing and computer vision algorithms in Python.
\end_layout

\begin_layout Standard
The goal of this paper is to evaluate the quality of the most common solution
 for developing CV algorithms and CV applications in Python.
 The outcomes of this evaluation aim to help with any decisional process
 for shifting to future CV development in Python from the traditional approach.
\end_layout

\begin_layout Standard
We have focused our attention on the performances of two widely used CV
 libraries in Python: 
\shape italic
OpenCV
\shape default

\begin_inset CommandInset citation
LatexCommand cite
key "bradski2000opencv"

\end_inset

 and 
\shape italic
NumPy/SciPy
\shape default

\begin_inset CommandInset citation
LatexCommand cite
key "oliphant2007python"

\end_inset

.
 For this matter, we analyzed their performances through a list of common
 tasks and processes regularly employed in computer vision (e.g.
 video capture, filtering algorithms, feature detection, etc).
 We were particularly interested to learn how Python performs in comparison
 with the native C implementation of OpenCV.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
need to rewrite last sentence.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
After an introduction of our experimental process, we will describe the
 list of tested CV tasks and algorithms and finally discuss our findings
 and provide recommendations.
\end_layout

\begin_layout Section
Experimental Process
\end_layout

\begin_layout Standard
In this section, we briefly introduce the different libraries we tested
 as our experimental protocol, the testing setup used as well as the tests
 themselves.
 We cover different standard algorithms traditionally used in a CV application
 and also some standard operations used in CV such as image acquisition.
 For each of the tests we describe the process, the difference in terms
 of the syntax, the performance and the usability.
 All of the testing code is made available open source at the project's
 website 
\begin_inset CommandInset href
LatexCommand href
name "http://code.google.com/p/pycam/wiki/PythonComputerVision"
target "http://code.google.com/p/pycam/wiki/PythonComputerVision"

\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Change this to hitlab project site later?
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Limitations in testing
\end_layout

\begin_layout Standard
Note that for some tests we only compare the Python OpenCV implementation
 against the SciPy library.
 Early results showed that the performance of OpenCV when called from Python
 performs similar to the native code making further testing redundant.
 
\end_layout

\begin_layout Standard
In some cases there was no analogous function in both OpenCV and SciPy,
 in which case we simply recommend to use the tool for the job.
\end_layout

\begin_layout Subsection*
Apparatus
\end_layout

\begin_layout Standard
We conducted our test on a Intel Core 2 Duo 6600 machine, with 3.8 RAM, running
 Ubuntu 9.04.
 For the test we compared: 
\end_layout

\begin_layout Itemize
OpenCV Native Language (OPENCV_C): we used snapshot built version 1.1.1, rev
 1978.
 The code has been compiled with the GNU tool chain version (4.3.3), and in
 Release mode with O3 compiler optimizations, MMX, fast math, SSE3.
 All additional packages, EXCEPT 1393, are turned on, for example: png,
 jpg, gtk, gstreamer, unicap, V4L turned on.
 
\end_layout

\begin_layout Itemize
OpenCV Python Wrapper (OPENCV_PY): we used the swig
\begin_inset CommandInset citation
LatexCommand cite
key "beazley1996swig"

\end_inset

 wrapper version 1.3.36.
 We used the same build of OpenCV as the native language.
 
\end_layout

\begin_layout Itemize
SciPy/NumPy (SCIPY): we used the stable versions from the Ubuntu repositories;
 SciPy version 0.7.0 and NumPy 1.2.1
\end_layout

\begin_layout Subsection*
Python
\end_layout

\begin_layout Standard
Python is a general purpose dynamic programming language
\begin_inset CommandInset citation
LatexCommand cite
key "entry-0"

\end_inset

.
 It is highly regarded due in no small part for its fast development time
 and the ease of integrating packages
\begin_inset CommandInset citation
LatexCommand cite
key "sanner1999python"

\end_inset

.
 Python's performance makes it a viable programming language for scientific
 work
\begin_inset CommandInset citation
LatexCommand cite
key "cai2005performance"

\end_inset

, and it has been used members in the CV community for many years
\begin_inset CommandInset citation
LatexCommand cite
key "doakPyCV"

\end_inset

.
\end_layout

\begin_layout Subsection*
OpenCV
\end_layout

\begin_layout Standard
Originally an Intel research initiative, 
\shape italic
OpenCV
\shape default
 cross-platform open source computer vision library is widely used for real
 time image processing.
 It aims to provide well tested, optimized and open source code for image
 processing and computer vision.
\end_layout

\begin_layout Standard
The library is written in C, ensuring both fast and portable code (optionally
 to embedded platforms).
 The library uses a base layer related to image structure and basic image
 manipulation.
 A software implementation is provided freely whilst an accelerated version
 (
\shape italic
IPP, Integrated Performance Primitives
\shape default

\begin_inset CommandInset citation
LatexCommand cite
key "taylor2004intel"

\end_inset

) can be optionally acquired from Intel.
 This latter option takes advantage of the extended multimedia instruction
 set available on Intel Processors.
\end_layout

\begin_layout Standard
Nowadays, multiple language bindings are available for OpenCV, such as OpenCVDot
Net and EmguCV.
 Additional tools using graphics hardware to accelerate Computer Vision
 performance have been made for OpenCV, GPUCV
\begin_inset CommandInset citation
LatexCommand cite
key "farrugia2006gpucv"

\end_inset

.
 Multiple bindings to OpenCV such as OpenCV Python, and PyCV
\begin_inset CommandInset citation
LatexCommand cite
key "tri2009principled"

\end_inset

 have been created for Python, as well as the automatically Swig
\begin_inset CommandInset citation
LatexCommand cite
key "beazley1996swig"

\end_inset

 wrapped bindings included with the source.
\end_layout

\begin_layout Subsection*
NumPy/SciPy
\end_layout

\begin_layout Standard

\emph on
NumPy
\emph default
 gives strongly typed N-dimensional array support to Python
\begin_inset CommandInset citation
LatexCommand cite
key "oliphant2006guide"

\end_inset

.
 It's a well recognized library, offering an easier approach for multidimensiona
l array manipulation than in the C programming language.
 Much of the lower level algorithms are implemented in highly optimized
 C and FORTRAN libraries, resulting in very fast raw data crunching and
 iterating.
\end_layout

\begin_layout Standard

\emph on
SciPy
\emph default

\begin_inset CommandInset citation
LatexCommand cite
key "jones2001scipy"

\end_inset

 is a set of Python libraries and tools for scientific and mathematical
 work built on top of NumPy
\begin_inset CommandInset citation
LatexCommand cite
key "oliphant2007python"

\end_inset

.
 SciPy offers many different modules including, many filters, routines for
 numerical integration and optimization.
 This leads to much more elegant code, usually achieved without any significant
 performance loss over C.
 Two major tools that are usually distributed with SciPy that are very use
 full for computer vision work are Matplotlib and IPython.
 Matplotlib
\begin_inset CommandInset citation
LatexCommand cite
key "hunter2007matplotlib"

\end_inset

 is an array and image plotting library, and IPython
\begin_inset CommandInset citation
LatexCommand cite
key "perez2007ipython"

\end_inset

 is an improved interactive shell for Python.
\end_layout

\begin_layout Section
Quantitative Tests
\end_layout

\begin_layout Subsection
Image Acquisition
\end_layout

\begin_layout Standard
Since live image acquisition is such a crucial role in the majority of CV
 applications, we tested getting and showing a frame as a most basic, but
 necessary test.
 This also serves to compare the syntax of the languages.
\end_layout

\begin_layout Subsubsection*
Acquiring and displaying an image in C with OpenCV
\end_layout

\begin_layout Standard
Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:C-Image-capture"

\end_inset

 opens up a new camera capture device, and takes one frame, it creates a
 new window and displays it
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
For brevity these code snippets do not carry out error checking or cleanup.
 It is assumed that a camera was found successfully and that a frame was
 available and returned.
 The C++ and Python versions of VideoCapturePlayer do carry out this error
 checking.
\end_layout

\end_inset

.
 Using this as a template it is straight forward to wrap the capture and
 display in a loop, this forms the basis of the C++ class 
\noun on
VideoCapturePlayer
\noun default
 used in the other tests to keep the code duplication and variation in timing
 to an absolute minimum.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement h
wide false
sideways false
status collapsed

\begin_layout LyX-Code
#include "cv.h"
\end_layout

\begin_layout LyX-Code
#include "highgui.h"
\end_layout

\begin_layout LyX-Code
int main(){
\end_layout

\begin_layout LyX-Code
  IplImage  *frame;
\end_layout

\begin_layout LyX-Code
  CvCapture *capture;
\end_layout

\begin_layout LyX-Code
  capture = cvCreateCameraCapture(0);
\end_layout

\begin_layout LyX-Code
  cvNamedWindow( "Snapshot", 0 );
\end_layout

\begin_layout LyX-Code
  frame = cvQueryFrame( capture );
\end_layout

\begin_layout LyX-Code
  cvShowImage( "Snapshot", frame );
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:C-Image-capture"

\end_inset

Image capture and display with OpenCV in C.
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Acquiring and displaying an image in Python with OpenCV
\end_layout

\begin_layout Standard
Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Python-Image-capture"

\end_inset

 does the same basic task of accessing a webcam and displaying one image
 in Python.
 The code is almost entirely identical in C and Python.
 The main difference being in the Python code no variables types are declared,
 this shows the dynamic nature of the language.
 As with C++, an object oriented version of this acquisition loop with error
 checking is used in further tests.
 The 
\noun on
VideoCapturePlayer
\noun default
 classes in both C++ and Python optionally take a function as an argument.
 This function takes the raw image, does some process on it, and returns
 an image for display.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement h
wide false
sideways false
status collapsed

\begin_layout LyX-Code
from opencv import highgui as hg
\end_layout

\begin_layout LyX-Code
capture = hg.cvCreateCameraCapture(0)
\end_layout

\begin_layout LyX-Code
hg.cvNamedWindow("Snapshot")
\end_layout

\begin_layout LyX-Code
frame = hg.cvQueryFrame(capture)
\end_layout

\begin_layout LyX-Code
hg.cvShowImage("Snapshot", frame)
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:Python-Image-capture"

\end_inset

Image capture and display in Python
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename report_data/streaming_from_webcam_in_opencv.png
	lyxscale 50
	width 80col%

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Streaming-comparison"

\end_inset

Comparison of Python and C++ performance using OpenCV for webcam capture
 and display.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Comparison
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Streaming-comparison"

\end_inset

 shows performance results for taking an image from a webcam and displaying
 the image with OpenCV.
 The average frames per second were taken with 3 iterations, each averaging
 the framerate over a 2 minute period.
 The error bars show standard deviation of the sampled data.
 As Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Streaming-comparison"

\end_inset

 shows, Python and C++ perform at very similar rates whilst carrying out
 an I/O bound task.
 C++ having the expected result of a marginally higher frame rate output
 than Python.
 The SciPy package does not currently have a direct method for image capture.
\end_layout

\begin_layout Subsection
Image Blur
\end_layout

\begin_layout Standard
One of the simplest operations in image processing is blurring an image.
 This can be achieved in a few ways, the method looked at here is by adding
 gaussian blur.
 Mathematically this is achieved by convolving the image with a gaussian
 filter.
 Because of the separability of multidimensional gaussian filters
\begin_inset CommandInset citation
LatexCommand cite
key "young1995recursive"

\end_inset

, the convolution can be applied in two ways; applying a 1 dimensional filter
 twice, once in each direction; or secondly the image can be convolved with
 a 2-dimensional gaussian filter created by the product of two 1 dimensional
 filters.
 Equation 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:1D Gaussian Filter"

\end_inset

 shows the gaussian function for obtaining the filter is in one dimension
\begin_inset CommandInset citation
LatexCommand cite
key "SS01"

\end_inset

.
 
\begin_inset Formula \begin{equation}
G\left(x\right)=\frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{x^{2}}{2\sigma^{2}}}\label{eq:1D Gaussian Filter}\end{equation}

\end_inset


\begin_inset Formula \begin{equation}
G\left(x,y\right)=\frac{1}{\sqrt{2\pi}\sigma^{2}}e^{-\frac{x^{2}+y^{2}}{2\sigma^{2}}}\label{eq:2D Gaussian Filter}\end{equation}

\end_inset

Equation 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:2D Gaussian Filter"

\end_inset

 shows the 2 dimensional case
\begin_inset CommandInset citation
LatexCommand cite
key "SS01"

\end_inset

.
 OpenCV includes a gaussian filter that can be applied to an image by calling
 the 
\emph on
\noun on
cvSmooth
\emph default
\noun default
 function and passing the desired window size.
 SciPy has a n-dimensional Gaussian filter that acts on a NumPy array.
 Both libraries use the 1 dimensional case, as it requires less calculations.
\end_layout

\begin_layout Standard
In all implementations of this test an object oriented approach is used,
 this ensures timing consistency between tests, and reduces code duplication.
 
\end_layout

\begin_layout Standard
The algorithms differ in that in order for the SciPy implementation to work,
 the image data must be converted into NumPy arrays before blurring.
 To continue using the OpenCV camera capture, the image data must be converted
 into NumPy arrays.
 This has been achieved by creating and using a Python decorator which converts
 before and after calling a Python function using NumPy.
 A (640x480) RGB image takes less than 2ms to convert either way on the
 testing platform used throughout this report.
 Also to ensure the same level of filtering is carried out in all tests,
 the filter parameters need converted to be compatible with OpenCV's 
\noun on
cvSmooth
\noun default
 defaults
\begin_inset CommandInset citation
LatexCommand cite
key "bradski2008learning"

\end_inset

.
\end_layout

\begin_layout Subsubsection*
Comparison
\end_layout

\begin_layout Standard
As expected the images produced by this are blurred as shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Gaussian-Output-Images"

\end_inset

.
 For qualitative comparison a static input image was used.
 What is not immediately obvious without further investigation is how similar
 the results are.
 The OpenCV images produced by C++ and Python are exactly the same pixel
 for pixel, this is expected because the same library is doing the filtering.
 More interesting is Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Difference-of-each"

\end_inset

 which shows that the SciPy and OpenCV Python code doing the filtering produces
 very similar but slightly different results.
 
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename report_data/blurred_imag_cpp_opencv_gaussian.jpg
	lyxscale 20
	width 30col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
C++
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename report_data/blurred_imag_python_opencv_gaussian.jpg
	lyxscale 20
	width 30col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Python OpenCV
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename report_data/blurred_imag_python_scipy_gaussian.jpg
	lyxscale 20
	width 30col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Python SciPy
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Gaussian-Output-Images"

\end_inset

Output Images from Gaussian Blur Examples
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename report_data/gaussian_diffs.png
	lyxscale 60
	width 95col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Difference-of-each"

\end_inset

Difference of each channel after gaussian blur in OpenCV and SciPy.
 Note the full scale is 255, Pixel for pixel difference image stats: maximum
 intensity difference = 20, average difference = 2.1, std dev = 1.4
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
This could be caused by a difference in the implementation of the gaussian
 kernel approximations.
 Since SciPy uses the sigma parameter, the filter is created by a direct
 sampling of the gaussian function.
 OpenCV on the other hand, uses the size of the filter, this is a good indicatio
n it probably uses the pascal triangle as a good approximation for the Gaussian
 kernel
\begin_inset CommandInset citation
LatexCommand cite
key "ben1991image"

\end_inset

.The graph in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Difference-of-each"

\end_inset

 shows a 3 way sub plot of a single image.
 This graph was created interactively using the Python plotting package
 Matplotlib from IPython acting directly on the data from OpenCV.
 With just two lines of Python code, which can be put anywhere in a computer
 vision program, we can pause execution and drop into a live interactive
 shell with full plotting capabilities.
 
\begin_inset Quotes eld
\end_inset


\emph on
from IPython.Shell import IPShellEmbed
\emph default

\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset


\emph on
IPShellEmbed()()
\emph default

\begin_inset Quotes erd
\end_inset

 This means that as developers, to debug a misbehaving program, we can just
 jump right into the middle of a deeply nested loop, introspect all variables,
 plot any signal or image, call any function, and accurately time the execution
 of any function.
 This is massively in favor of using Python.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename report_data/gaussian_blur.png
	lyxscale 50
	width 80col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:performance-gaussian"

\end_inset

OpenCV performance carrying out Gaussian Blur
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Background subtraction
\end_layout

\begin_layout Standard
A common task in security surveillance, human interaction, and CV in general
 is to detect movement in a video.
 This is done in its simplest form by a comparison of one frame to another
 previous frame
\begin_inset CommandInset citation
LatexCommand cite
key "gao2006robust"

\end_inset

.
 If there is more than a threshold of difference, something changed.
 The response is shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Adding-a-single"

\end_inset

 after adding a cellphone to the scene for the 
\noun on
Python_CV
\noun default
 implementation.
 As Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:BackgroundSubtract_graph"

\end_inset

 shows, the performance is very close for Python and C++ versions using
 OpenCV.
 Python was faster on average, but more varied.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename report_data/background_subtraction.png
	lyxscale 50
	width 95col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:BackgroundSubtract_graph"

\end_inset

Background subtraction performance
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename report_data/background_python_add_item.png
	lyxscale 40
	width 30col%

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Adding-a-single"

\end_inset

Adding item
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename report_data/background_python_add_more_items.png
	lyxscale 40
	width 30col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Adding-another-item,"

\end_inset

minor problems
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename report_data/background_python_add_remove_item.png
	lyxscale 40
	width 30col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:remove-laptop"

\end_inset

Addition and removal
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:background-Adding-and-removing"

\end_inset

Background subtraction response to adding and removing items from a scene.
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename report_data/background_python_before.png
	lyxscale 40
	width 30col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
before
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename report_data/background_python_add_items_complicated.png
	lyxscale 40
	width 30col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
program output
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename report_data/background_python_after.png
	lyxscale 40
	width 30col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
after
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:back-Proces-clutter"

\end_inset

Background subtraction response on a cluttered scene where a cellphone is
 switched for a wallet and a contact card is added.
\end_layout

\end_inset


\end_layout

\end_inset

 While creating this program, we found IPython particularly helpful, it
 allows for interactive, in place trialing, timing and plotting as shown
 in algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Interactive,-inplace-timing"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
In [1]: from opencv import cv
\end_layout

\begin_layout Plain Layout
\noindent
In [2]: cv.cvAnd(diffImage,image, temp)
\end_layout

\begin_layout Plain Layout
\noindent
In [3]: timeit cv.cvAnd(diffImage,image, temp)
\end_layout

\begin_layout Plain Layout
\noindent
1000 loops, best of 3: 229 µs per loop
\end_layout

\begin_layout Plain Layout
\noindent
In [4]: from pylab import imshow, show
\end_layout

\begin_layout Plain Layout
\noindent
In [5]: imshow(temp) 
\end_layout

\begin_layout Plain Layout
\noindent
Out[5]: <AxesImage object at 0x42489d0>
\end_layout

\begin_layout Plain Layout
\noindent
In [6]: show()
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:Interactive,-inplace-timing"

\end_inset

Using IPython, the interactive shell can be used from deep inside a nested
 loop in a running program.
 In place timing and plotting with access to local variables and functions
 like this example speeds up development time.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Feature Point Detection
\end_layout

\begin_layout Standard
Many methods in computer vision for identifying the contents of an image
 relies on extracting 
\emph on
interesting
\emph default
 features.
 An interesting feature point could be corners of intersecting lines, a
 line ending, or any isolated point where local image regions have a high
 degree of variation in all directions
\begin_inset CommandInset citation
LatexCommand cite
key "harris1988combined"

\end_inset

.
 The features must be found algorithmically and have a well-defined position.
 The repeatability of choosing the same points under differing conditions
 is a measure of how good an interesting feature algorithm is.
 The corner detection algorithm works by locating points where the surroundings
 have edges in more than one direction.
 According to 
\begin_inset CommandInset citation
LatexCommand cite
key "Sol09"

\end_inset

 the Harris & Stephens algorithm is in short: 
\end_layout

\begin_layout Quote
A matrix W is created from the outer product of the image gradient, this
 matrix is averaged over a region and then a corner response function is
 defined as the ratio of the determinant to the trace of W.
\end_layout

\begin_layout Standard
A threshold is then applied to this corner response image to pick the most
 likely candidates and then these points are plotted.
 An example usage of the algorithm is in the Lucas–Kanade Optical Flow Method
 where it can be used to select good feature points
\begin_inset CommandInset citation
LatexCommand cite
key "beauchemin1995computation"

\end_inset

 for tracking movement.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename harris_scipy_static.png
	lyxscale 40
	width 45col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:harris_scipy_static"

\end_inset

SciPy
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename harris_response_lena_opencv.jpg
	lyxscale 40
	width 45col%

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
OpenCV
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:harris_compare_static"

\end_inset

Running the Harris & Stephens feature detection algorithm on the Lena test
 image.
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename report_data/feature_detect/scipy_harris.png
	lyxscale 30
	width 45col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:harris_webcam_scipy"

\end_inset

SciPy (~4fps)
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename report_data/feature_detect/opencv_harris.png
	lyxscale 30
	width 45col%

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
OpenCV (~9fps)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:harris_compare_webcam"

\end_inset

Feature detection running on webcam stream
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We took and modified an existing implementation in SciPy by 
\begin_inset CommandInset citation
LatexCommand cite
key "Sol09"

\end_inset

 which produced Figures 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:harris_webcam_scipy"

\end_inset

 & 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:harris_scipy_static"

\end_inset

.
 The algorithm was timed by executing it on Lena 300 times per sample:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="3">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sample:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mean
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Std
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SciPy
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
191.5 ms
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.87 ms
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
OpenCV
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
65.7 ms
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1.27 ms
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
The same concept but in a different implementation is shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:harris_compare_webcam"

\end_inset

 for OpenCV.
 A filter kernel size of 3 pixels was used when computing the harris response,
 the authors did note that with a larger kernel SciPy seemed to slow down
 more than OpenCV.
 The threshold filtering and display of the corner response was implemented
 solely in OpenCV to reduce differences; the SciPy implementation therefore
 had an extra data conversion stage.
 Another limitation is that the OpenCV response in C++ is not implemented
 here.
\end_layout

\begin_layout Subsection
Face Detection
\end_layout

\begin_layout Standard
Face detection is the task of identifying the presence of any number of
 faces in an image, this is a specific case of general object detection.
 Before locating an object, one must be able to describe it.
 Many object detection algorithms use a strong classifier which is built
 from a collection of weak feature patterns made by scanning a database
 of images with known contents
\begin_inset CommandInset citation
LatexCommand cite
key "viola2004robust"

\end_inset

.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:OpenCV-Face-Detection"

\end_inset

 shows the output from our tests running under different conditions when
 using the face Haar-cascade classifier that comes with OpenCV.
 The method gave a mean framerate of 7.16 ± 0.02 Hz.
 The detection process itself gave very consistent timings of 107 ± 1 ms.
 The detection method used has limitations as shown in Figures 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Obscured-opencv-face"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Angled-opencv-face"

\end_inset

, this is caused because the classifier was only trained on straight on
 face images.
 But in ideal conditions, with good lighting and un-obscured faces directly
 facing the camera the algorithm produces very robust results.
 There is no corresponding high level functionality in SciPy, so a performance
 comparison was not possible.
 A recent project PyCV
\begin_inset CommandInset citation
LatexCommand cite
key "tri2009principled"

\end_inset

 improves on the face detection in OpenCV utilizing SciPy.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename report_data/face_detect_one.png
	lyxscale 30
	width 45col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Single face in frame
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename report_data/face_detect_obscure.png
	lyxscale 30
	width 45col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Obscured-opencv-face"

\end_inset

Obscured face in frame
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename report_data/face_detect_two.png
	lyxscale 30
	width 45col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Multiple faces
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename report_data/face_detect_sideways.png
	lyxscale 30
	width 45col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Angled-opencv-face"

\end_inset

Rotated face
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:OpenCV-Face-Detection"

\end_inset

OpenCV Face Detection
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename report_data/pygame-eye-locate.png
	lyxscale 50
	width 40col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
detecting face objects
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename report_data/pygame-face-edge.png
	lyxscale 40
	width 40col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:edge-filtering-face"

\end_inset

edge filtering and face detection
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Pygame-object"

\end_inset

Pygame can be used to capture and display the webcam, while OpenCV does
 the processing.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Pygame-object"

\end_inset

 shows an alternative setup; using the Pygame camera module for image capture,
 OpenCV for the object detection and Pygame surfaces for the box rendering
 and display.
 Python really shows its strengths as a glue language here, as the different
 libraries are easily used in conjunction with each other.
 The benefits from this can be huge, it is very easy for a developer to
 incorporate different computer vision tools, even with very limited knowledge
 of computer vision.
 We found that calling OpenCV from a Python wrapper was only slightly slower
 in general than natively using the library.
 
\end_layout

\begin_layout Section
Qualitative Comparison
\end_layout

\begin_layout Standard
In getting these quantitative results we noticed that the Python implementations
 were shorter, easier to create, easier to debug, and easier to test.
 Having the use of an interactive interpreter, to come to a solution prototype
 and being able to use these prototypes in the final product is a big argument
 in favor of using Python.
 
\end_layout

\begin_layout Standard
The documentation in both SciPy and OpenCV was found to be complete, but
 not as extensive as for a professional package like Matlab.
 Support for these open source packages is almost entirely reliant on experience
d members of the community responding to requests on message boards or mailing
 lists.
 When one of the authors asked a question regarding the gaussian image filtering
 function to the SciPy mailing list it spurred not only an immediate response
 pointing out the solution to the direct query but also a discussion on
 finite approximations to gaussian kernels, how OpenCV might do it differently.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
A user even went as far as to test and propose a new IIR filter implementation
 for SciPy that scales better with kernel size than the existing implementations.
\end_layout

\end_inset

 This kind of support is common in the open source world, where a package
 like SciPy prides itself on its very rigorous and open tests.
 
\end_layout

\begin_layout Standard
For the scholar of computer vision research we find that using Python can
 help in trying out new algorithms very quickly.
 The breadth of the additional libraries available and the ease of integrating
 make new and novel solutions quickly realizable.
 
\end_layout

\begin_layout Standard
For those newer to computer vision, we can recommend Python for many reasons,
 it is much more forgiving than C or C++, it can be used interactively so
 you can happily make 10 mistakes in a row, without having to recompile
 and start execution again for each attempted fix.
\end_layout

\begin_layout Standard
A major limitation of using Python would be when the application is being
 developed for special or embedded hardware or when the best possible performanc
e is required.
 The stability of the packages is also somewhat in question, OpenCV's Python
 bindings are being rewritten manually to replace the SWIG produced bindings
 and SciPy is still relatively new.
\end_layout

\begin_layout Section
Related Works
\end_layout

\begin_layout Standard
A feature of SciPy that has previously gone unmentioned, is the Weave module
 for in-lining C and C++ code.
 This can produce code 100x faster
\begin_inset CommandInset citation
LatexCommand cite
key "ramachandran-performance"

\end_inset

 than pure Python.
 
\begin_inset CommandInset citation
LatexCommand cite
key "cai2005performance"

\end_inset

 showed that for parallel programming, mixed language solutions exhibit
 the same performance gains as native language solutions from moving to
 parallel solutions.
 A different direction for parallel solutions is to harness the power of
 the graphics card many desktop computers have, the PyGPU and the GPUCV
 projects both allow using this technology from Python
\begin_inset CommandInset citation
LatexCommand cite
key "lejdfors2006implementing"

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "farrugia2006gpucv"

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "allusse2008gpucv"

\end_inset

.
\end_layout

\begin_layout Standard
Another related area of research is the performance of Python itself.
 One such project was the Psyco 
\emph on
just in time compiler
\emph default
 for Python
\begin_inset CommandInset citation
LatexCommand cite
key "rigo2004representation"

\end_inset

, unfortunately Psyco only works on Python 2.6.X and on x86 machines.
 The developer of Psyco is currently working on the performance of PyPy,
 a compliant, flexible and fast implementation of the Python Language.
 Google is currently midway through their 
\noun on
Unladen Swallow
\noun default
 project which aims to speed up Python by leveraging the Low Level Virtual
 Machine (LLVM).
 All of these projects help make Python a safe bet for the future of scientific
 computing and specifically for use in the computer vision domain.
\end_layout

\begin_layout Itemize
Performance speed ups with NumPy
\begin_inset CommandInset citation
LatexCommand cite
key "cai2005performance"

\end_inset


\end_layout

\begin_layout Itemize
GPUCV
\end_layout

\begin_layout Itemize
Pyro - 
\begin_inset CommandInset citation
LatexCommand cite
key "blank2003pyro"

\end_inset

 introduced Pyro, a robotics simulation environment
\end_layout

\begin_layout Itemize
Pygame - a game making package for Python, aimed at new programmers.
 It has a camera module and is able to do basic computer vision tasks, or
 call on any other Python library e.g.
 SciPy/NumPy.
 http://Pygame.org
\end_layout

\begin_layout Itemize
Pycam - All test and example code from this project.
 http://pycam.googlecode.com
\end_layout

\begin_layout Subsection*
Acknowledgments
\end_layout

\begin_layout Standard
Thanks to all the developers that invest their own valuable time to work
 on open source projects OpenCV, Python and SciPy.
\end_layout

\begin_layout Section
Appendix
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "report_data/database"
options "ieeetr"

\end_inset


\end_layout

\end_body
\end_document
